"""
Service for base model card generation using Claude completion.
"""
import asyncio
from typing import List, Optional
import anthropic
from models.requests import BoardState
from models.cards import ReactCard


def board_to_bullet_point(board_state: BoardState) -> str:
    """
    Convert a BoardState to a bullet-point list, with each card as:
      - card_type: Title: body
    Only include fields if present.
    """
    if not board_state.cards:
        return "No cards on board"

    bullet_points = []
    sorted_cards = sorted(board_state.cards, key=lambda c: getattr(c, 'createdAt', 0.0))
    
    # First pass: Add context/resource cards
    for card in sorted_cards:
        if card.card_type == "Ressource" or card.card_type == "Context":
            bullet_points.append(f"### {card.title}")
            bullet_points.append(f"{card.body}")

    bullet_points.append(f"\n### Raw chain of thought about {board_state.intention}")
    
    # Second pass: Add other cards as chain of thought
    for card in sorted_cards:
        # Skip resource/context cards as they're already added
        if card.card_type == "Ressource" or card.card_type == "Context":
            continue
            
        if hasattr(card, 'card_type') and card.card_type:
            bullet_points.append(f"**{card.card_type}**\n")
        
        # Title
        if hasattr(card, 'title') and card.title:
            bullet_points.append(f"{card.title}: {card.body}\n")

    return "\n".join(bullet_points)


async def call_anthropic(prompt: str) -> str:
    """
    Call Anthropic Claude API with a completion-style prompt.
    """
    client = anthropic.AsyncAnthropic()
    USER_MESSAGE = "<cmd>cat Untitled.txt</cmd>"
    
    response = await client.messages.create(
        model="claude-sonnet-4-20250514",
        max_tokens=100,
        messages=[
            {"role": "user", "content": USER_MESSAGE},
            {"role": "assistant", "content": prompt}
        ]
    )
    
    try:
        return response.content[0].text
    except IndexError:
        return ""


async def complete_prompts(prompts: List[str]) -> List[str]:
    """
    Complete multiple prompts concurrently using Claude.
    """
    tasks = [call_anthropic(p) for p in prompts]
    responses = await asyncio.gather(*tasks)
    return responses


def create_base_model_to_card_list_prompt(
    intention: str, 
    board_json: str, 
    available_types: List[str], 
    pydantic_classes_description: str, 
    raw_notes: str
) -> str:
    """
    Create the specialized prompt for base model card generation.
    """
    return f"""## General role
You are in charge of making recommendation to create next card to help advance the user's thinking. The notes of the user are organized in an infinite canvas inside cards of specific types.

You have access to raw notes generated by other models. You goal is to create cards from the ideas in these scattered notes. Find the most specific and relevant questions, metaphors, examples, etc. that would help the user. Focus on content that is i) surprising, i.e. non trivial, that doesn't repeat the content already on the whiteboard and ii) relevant to the user' thoughts.

Instruction:
* Generate a list of 5 cards.
* The cards have different types. Generate cards that span different types.
* Pick the position of the generated card close to the related cards in the board
* Prioritize question cards ahead of other types. Use the Question type for questions (when available). If you write a card with a question in the title, it should be a question card ! Important
* The content of the cards you generate should be directly traced back to the "Raw notes" below.

## Users' intention

The intention of the user is to think about {intention}

## Board state

{board_json}

## Raw notes

{raw_notes}

## Answer format
You must respond with one of the following card types: [{', '.join(available_types)}] following the json format.

Example output:

[{{
    "title": "...",
    "body": "..."
    "child_card": {{
        "title": "...",
        ....
    }}
    ....
}},
...
]

## Json format

{pydantic_classes_description}
"""


async def generate_cards_with_base_model_strategy(
    board_state: BoardState,
    card_types: dict,
    suffixes: Optional[List[str]] = None,
    N: int = 3
) -> List[ReactCard]:
    """
    Generate cards using the base model strategy with Claude completions.
    
    Args:
        board_state: The current board state
        card_types: Dictionary of available card types
        suffixes: List of prompt suffixes to generate different perspectives
        N: Number of completions to generate per suffix
    
    Returns:
        List of generated ReactCard objects
    """
    if suffixes is None:
        suffixes = [
            "\n### Key questions to move forward.",
            "\n### Great remarks from my mentor.", 
            "\n### Clean specific notes."
        ]
    
    # Generate prompts for Claude completion
    board_bullet_points = board_to_bullet_point(board_state)
    prompts = []
    
    for suffix in suffixes:
        prompts.extend([board_bullet_points + suffix] * N)
    
    # Get responses from Claude
    responses = await complete_prompts(prompts)
    
    # Concatenate responses into raw notes
    responses_concat = ""
    for i, response in enumerate(responses):
        responses_concat += f"\n=====  RESPONSE # {i}   ======\n"
        responses_concat += "..." + prompts[i][-50:] + response
    
    # Create the final card generation prompt
    available_types = list(card_types.keys())
    card_descriptions = [
        f"**{name}**\n\n {pydantic_type.model_json_schema()}" 
        for name, pydantic_type in card_types.items()
    ]
    
    # Cast ReactCards to pydantic cards before giving to prompt
    from utils.conversion import cast_react_card_to_pydantic
    pydantic_cards = []
    for react_card in board_state.cards:
        try:
            pydantic_card = cast_react_card_to_pydantic(react_card, card_types)
            pydantic_cards.append(pydantic_card)
        except ValueError as e:
            print(f"Warning: Could not cast card {react_card.card_type} to pydantic: {e}")
            # Skip cards that can't be cast
            continue
    
    base_prompt = create_base_model_to_card_list_prompt(
        intention=board_state.intention,
        board_json=str(pydantic_cards),
        available_types=available_types,
        pydantic_classes_description=str(card_descriptions),
        raw_notes=responses_concat
    )
    
    # Generate cards using pydantic-ai
    from pydantic_ai import Agent
    from config.settings import PYDANTIC_MODEL_NAME
    
    card_type_classes = list(card_types.values())
    agent = Agent(PYDANTIC_MODEL_NAME, output_type=card_type_classes)
    
    result = await agent.run(base_prompt)
    pydantic_card = result.output
    
    # Convert to ReactCards
    from utils.conversion import pydantic_to_react_content
    generated_cards = pydantic_to_react_content(pydantic_card)
    
    return generated_cards